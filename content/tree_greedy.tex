\maketitle

En esta sección se expone la idea de los algoritmos Greedy para resolver el problema en dos casos particulares: cuando el grafo es un árbol y cuando es un bosque.

\section{Caso en que el grafo es un árbol}

Dado un árbol \( T = (V,E) \) con pesos no negativos en sus aristas, la idea es aprovechar la propiedad de que, al remover \( k-1 \) aristas, el árbol se divide en \( k \) componentes conexas. El algoritmo Greedy consiste en:
\begin{enumerate}
    \item Ordenar las aristas del árbol en forma no decreciente según su peso.
    \item Seleccionar las \( k-1 \) aristas de menor peso.
\end{enumerate}

\subsection{Análisis de Complejidad}
\begin{itemize}
    \item Ordenar las aristas requiere \( O(n \log n) \), donde \( n \) es el número de vértices (recordando que un árbol tiene \( n-1 \) aristas).
    \item La selección de las \( k-1 \) aristas es \( O(k) \), lo cual es polinomial.
\end{itemize}
Por lo tanto, el algoritmo Greedy para árboles se resuelve en tiempo polinomial.

\subsection{Demostración de Correctitud}

Recordemos que, en un árbol, al eliminar ciertas aristas se incrementa el número de componentes conexas.

\begin{lemma}[Número de componentes en un árbol]
Si eliminamos todas las aristas de un árbol con \( n \) vértices, es decir, eliminamos \( n-1 \) aristas, obtenemos \( n \) componentes conexas.
\end{lemma}

\begin{proof}
Procedemos por inducción en el número de vértices \( n \).

\textbf{Caso base:}  
Si \( n = 2 \), un árbol tiene exactamente una arista. Al remover esta única arista, el grafo se divide en 2 componentes conexas, lo cual cumple la afirmación.

\textbf{Hipótesis de inducción:}  
Supongamos que para un árbol con \( n = k-1 \) vértices, removiendo \( (k-2) \) aristas obtenemos \( k-1 \) componentes conexas.

\textbf{Paso inductivo:}  
Consideremos un árbol \( T \) con \( k \) vértices. Removamos una arista \( e \) del árbol. Al hacerlo, el árbol se divide en dos subárboles, digamos \( T_1 \) y \( T_2 \), que tienen \( n_1 \) y \( n_2 \) vértices respectivamente, donde \( n_1 + n_2 = k \) y ambos \( n_1, n_2 \ge 1 \).  
Por la hipótesis de inducción, removiendo \( n_1 - 1 \) aristas de \( T_1 \) se obtienen \( n_1 \) componentes conexas y removiendo \( n_2 - 1 \) aristas de \( T_2 \) se obtienen \( n_2 \) componentes conexas.  
En total, removiendo \( 1 + (n_1 - 1) + (n_2 - 1) = n_1 + n_2 - 1 = k - 1 \) aristas, obtenemos \( n_1 + n_2 = k \) componentes conexas.  
\end{proof}

\subsection{Pseudocódigo}

\begin{lstlisting}
Entrada: Árbol T = (V, E) con pesos no negativos, entero k
Salida: Conjunto de aristas C que forma un corte mínimo k

1. Ordenar las aristas E de T en forma no decreciente según su peso: 
      w(e1) <= w(e2) <= ... <= w(e_{|V|-1})
2. Seleccionar las primeras k-1 aristas de la lista ordenada y asignarlas a C.
3. Retornar C.
\end{lstlisting}

\section{Caso en que el grafo es un bosque}

Para un bosque \( F = (V,E) \) con \( t \) componentes conexas, la idea es similar. Se debe notar que, para obtener una partición en \( k \) componentes, es necesario remover \( k-t \) aristas, ya que el bosque ya cuenta con \( t \) componentes. El algoritmo Greedy consiste en:
\begin{enumerate}
    \item Ordenar todas las aristas del bosque en forma no decreciente según su peso.
    \item Seleccionar las \( k-t \) aristas de menor peso.
\end{enumerate}

\subsection{Análisis de Complejidad}
\begin{itemize}
    \item Ordenar las aristas requiere \( O(|E| \log |E|) \); dado que el bosque tiene a lo sumo \( |V|-1 \) aristas, se cumple que es polinomial.
    \item La selección de las \( k-t \) aristas es \( O(k) \).
\end{itemize}
Por lo tanto, este algoritmo también se ejecuta en tiempo polinomial.

\subsection{Pseudocódigo}

\begin{lstlisting}
Entrada: Bosque F = (V, E) con pesos no negativos, entero k, 
         donde t es el número de componentes conexas en F.
Salida: Conjunto de aristas C que forma un corte mínimo k en F

1. Calcular t, el número de componentes conexas de F.
2. Ordenar las aristas E de F en forma no decreciente según su peso:
      w(e1) <= w(e2) <= ... <= w(e_{|V|-?})
3. Seleccionar las primeras k-t aristas de la lista ordenada y asignarlas a C.
4. Retornar C.
\end{lstlisting}
